{"meta":{"title":"Amaris's blog","subtitle":"","description":"Less is more.","author":"Amaris","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Tcp套接字详解—C语言实现","slug":"TCP套接字详解—C语言实现","date":"2020-01-05T11:00:21.000Z","updated":"2020-02-29T12:03:48.111Z","comments":true,"path":"2020/01/05/TCP套接字详解—C语言实现/","link":"","permalink":"http://yoursite.com/2020/01/05/TCP%E5%A5%97%E6%8E%A5%E5%AD%97%E8%AF%A6%E8%A7%A3%E2%80%94C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/","excerpt":"基于C语言实现TCP套接字通信 本文旨在windows系统中使用TCP套接字实现客户端/服务端通信编译器：visual studio 2019 (community) Socket本意翻译为插座，这其实很形象的解释了套接字的作用，在客户端与服务端的通信中，套接字就起着像插座一样连接的作用。TCP套接字与UDP套接字最大的区别便是是否面向连接，本文所实现的便是面向连接的TCP套接字，即客户端与服务端在通信之前进行三次握手建立连接。","text":"基于C语言实现TCP套接字通信 本文旨在windows系统中使用TCP套接字实现客户端/服务端通信编译器：visual studio 2019 (community) Socket本意翻译为插座，这其实很形象的解释了套接字的作用，在客户端与服务端的通信中，套接字就起着像插座一样连接的作用。TCP套接字与UDP套接字最大的区别便是是否面向连接，本文所实现的便是面向连接的TCP套接字，即客户端与服务端在通信之前进行三次握手建立连接。 TCP服务端建立步骤： 申请套接字：s = socket(…); 确定本地端点，填写端点地址：address = …; 建立套接字与端点关系（绑定）：bind(s,address…); 设置为监听模式：listen(s); 接收连接：newsock = accept(s); 数据收/发：recv(newsock); / send(newsock); 关闭套接字：closesocket(newsock); TCP客户端建立步骤： 申请套接字：s = socket(…); 确定本地端点，填写端点地址：c_address = …; 建立套接字与端点关系（绑定)：bind(s,c_address…); 确定服务器端点：s_address = …; 与服务器建立连接：connect(s,s_address…); 数据发/收：send(s); / recv(s); 关闭套接字：closesocket(s); TCP服务端代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#pragma comment(lib,\"ws2_32.lib\")int main(int argc, char* argv[])&#123; //初始化WSA WORD sockVersion = MAKEWORD(2, 2); WSADATA wsaData; if (WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; return 0; &#125; //创建套接字 SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (slisten == INVALID_SOCKET) &#123; printf(\"socket error !\"); return 0; &#125; //绑定IP和端口 sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.S_un.S_addr = INADDR_ANY; if (bind(slisten, (LPSOCKADDR)&amp; sin, sizeof(sin)) == SOCKET_ERROR) &#123; printf(\"bind error !\"); &#125; //开始监听 if (listen(slisten, 5) == SOCKET_ERROR) &#123; printf(\"listen error !\"); return 0; &#125; //循环接收数据 SOCKET sClient; sockaddr_in remoteAddr; int nAddrlen = sizeof(remoteAddr); char revData[255]; while (true) &#123; printf(\"等待连接...\\n\"); sClient = accept(slisten, (SOCKADDR*)&amp; remoteAddr, &amp;nAddrlen); if (sClient == INVALID_SOCKET) &#123; printf(\"accept error !\"); continue; &#125; printf(\"接受到一个连接：%s \\r\\n\", inet_ntoa(remoteAddr.sin_addr)); srand((unsigned)time(NULL)); for (int i = 0; i &lt;= 20; i++) &#123;//接收数据 int ret = recv(sClient, revData, 255, 0); //int my_revdata = int(*revData);// *（int* (const char*)revData) int my_revdata = *((int*)(revData)); if (ret &gt; 0) &#123; revData[ret] = 0x00; //int b = int(*revData); //printf(revData); printf(\"成功接受数据：%3d\", my_revdata); &#125; //发送数据 int randData = rand() % 500; randData = abs(randData); int my_sendData = my_revdata + randData; printf(\"我发送的数据：%5d \\n\", my_sendData); send(sClient, (const char*)(&amp;my_sendData), sizeof(my_sendData), 0); &#125; closesocket(sClient); &#125; closesocket(slisten); WSACleanup(); return 0;&#125; TCP客户端代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;WINSOCK2.H&gt;#include &lt;STDIO.H&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include&lt;windows.h&gt;#pragma comment(lib,\"ws2_32.lib\")int main(int argc, char* argv[])&#123; WORD sockVersion = MAKEWORD(2, 2); WSADATA data; if (WSAStartup(sockVersion, &amp;data) != 0) &#123; return 0; &#125; SOCKET sclient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (sclient == INVALID_SOCKET) &#123; printf(\"invalid socket !\"); return 0; &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); if (connect(sclient, (sockaddr*)&amp; serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(\"connect error !\"); closesocket(sclient); return 0; &#125; srand((unsigned)time(NULL)); for (int i = 0; i &lt; 20; i++) &#123; Sleep(500); int a = rand() % 500; a = abs(a); printf(\"我发送的随机数：%3d \", a); send(sclient, (const char*)(&amp;a), sizeof(a), 0); char recData[255]; int ret = recv(sclient, recData, 255, 0); int d = *((int*)(recData)); if (ret &gt; 0) &#123; recData[ret] = 0x00; if (d &gt; 100) &#123; printf(\"成功接收返回数据：\"); printf(\"%5d\\n\", d); &#125; else &#123; printf(\"数据不符合要求！\\n\"); &#125; &#125; &#125; closesocket(sclient); WSACleanup(); return 0;&#125;","categories":[],"tags":[{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}]}]}